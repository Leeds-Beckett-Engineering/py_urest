<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>urest.http.server API documentation</title>
<meta name="description" content="Micro HTTP server dedicated to REST-style API Requests. Inspired by the
[MicroPython HTTP â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>urest.http.server</code></h1>
</header>
<section id="section-intro">
<p>Micro HTTP server dedicated to REST-style API Requests. Inspired by the
<a href="https://github.com/erikdelange/MicroPython-HTTP-Server">MicroPython HTTP Server</a>
by Erik de Lange, as a simple consumer of the Python 3 <code>asyncio</code> library for the
low-level socket handling and use of co-routines to simplify request handling.</p>
<p>This version is written for MicroPython 3.4, and has been tested on:</p>
<ul>
<li>Raspberry Pi Pico W</li>
</ul>
<h2 id="standards">Standards</h2>
<ul>
<li>For HTTP/1.1 specification see: <a href="https://www.ietf.org/rfc/rfc2616.txt">https://www.ietf.org/rfc/rfc2616.txt</a></li>
</ul>
<h2 id="licence">Licence</h2>
<p>This module, and all included code, is made available under the terms of the MIT
Licence</p>
<blockquote>
<p>Copyright 2022 (c) Erik de Lange, Copyright (c) 2022-2023 David Love</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Micro HTTP server dedicated to REST-style API Requests. Inspired by the
[MicroPython HTTP Server](https://github.com/erikdelange/MicroPython-HTTP-Server)
by Erik de Lange, as a simple consumer of the Python 3 `asyncio` library for the
low-level socket handling and use of co-routines to simplify request handling.

This version is written for MicroPython 3.4, and has been tested on:

  * Raspberry Pi Pico W


Standards
---------

  * For HTTP/1.1 specification see: https://www.ietf.org/rfc/rfc2616.txt

Licence
-------

This module, and all included code, is made available under the terms of the MIT
Licence

&gt; Copyright 2022 (c) Erik de Lange, Copyright (c) 2022-2023 David Love

&gt; Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#34;Software&#34;), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

&gt; The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

&gt; THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
&#34;&#34;&#34;

# Import the standard error library
import errno

# Import the Asynchronous IO Library, preferring the MicroPython library if
# available
try:
    import uasyncio as asyncio
except ImportError:
    import asyncio

# Import the RAWResponse class
from .response import HTTPResponse

# Import the API Base class
from ..api.base import APIBase

##
## Constants
##

ASCII_UPPERCASE = set(&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;)
DIGITS = set(&#34;0123456789&#34;)
JSON_TYPE = {&#34;STR&#34;, &#34;INT&#34;, &#34;ERROR&#34;}

##
## Exceptions
##


class RESTServerError(Exception):
    pass


class RESTParseError(Exception):
    pass


##
## Classes
##


class RESTServer:

    #
    def __init__(
        self,
        host: str = &#34;0.0.0.0&#34;,
        port: int = 80,
        backlog: int = 5,
        read_timeout: int = 30,
        write_timeout: int = 5,
    ):
        &#34;&#34;&#34;Initialise the server with reasonable defaults. These should work
        for most cases, and should be set so that most clients won&#39;t have
        to touch them.

        The `urest.http.server.RESTServer` class acts as the primary interface
        to the library, handling all the network communication with the client,
        formatting the response and marshalling the API calls required to generate that
        response.

        In most cases consumers of this module will create a single instance of
        the `urest.http.server.RESTServer` class, and then pass the reference to the
        `urest.http.server.RESTServer.start` method to an event loop of the `asyncio`
        library.

        For example the following code creates a variable `app` for the instance
        of the `urest.http.server.RESTServer` class, and passes this to the &#39;main&#39; event
        loop of the `asyncio` library

        ```python
        app = RESTServer()


        if __name__ == &#34;__main__&#34;:
          loop = asyncio.get_event_loop()
          loop.create_task(app.start())
          loop.run_forever()
        ```

        The `urest.http.server.RESTServer.start` method is expected to be used
        in a [`asyncio` event
        loop](https://docs.python.org/3.4/library/asyncio-eventloop.html), as above;
        with the tasks being handled by the `urest.http.server.RESTServer.dispatch_noun`
        method. If the event loop is required to be closed, or destroyed, the tasks
        can be removed using the `urest.http.server.RESTServer.stop` method.

        .. Note::
          The code in this class assumes the `asyncio` library with an interface
          roughly equivalent to Python 3.4: although the MicroPython module supports _some_
          later extensions. Given the code churn in the `asyncio` module between Python 3.4
          and Python 3.10, careful testing is required to ensure implementation compatibility.

        Parameters
        ----------

        host: string
            A resolvable DNS host name or IP address. Note that the exact requirements are
            determined by the
            [`asyncio.BaseEventLoop.create_server`](https://docs.python.org/3.4/library/
            asyncio-eventloop.html#asyncio.BaseEventLoop.create_server) method, which should
            be checked carefully for implementation defined limitations.

            **Default:** An IPv4 sock on the local host.

        port: integer
            The local (server) port to bind the socket to. Note that the exact requirements are
            determined by the
            [`asyncio.BaseEventLoop.create_server`](https://docs.python.org/3.4/library/
            asyncio-eventloop.html#asyncio.BaseEventLoop.create_server) method, which should
            be checked carefully for implementation defined limitations (e.g. extra privileges
            required for system ports).

            **Default:** The IANA Assigned port 80 for an HTTP Server.

        backlog: integer
            Roughly the size of the pool of connections for the underlying
            `socket`. Once this value has been exceeded, the tasks will be suspended by the
            co-routine handler until the underlying `socket` can clear them. Note that the
            size (and interpretation) of this value is system dependent: see the [`socket`
            API](https://docs.python.org/3.4/library/socket.html#module-socket) for more
            details.

            **Default:** 5 (typically the maximum pool size allowed).

        read_timeout: integer
            Length of time in seconds to wait for a response from the client before declaring
            failure.

            **Default:** 30 seconds.

        write_timeout: integer
            Length of time in seconds to wait for the network socket to accept a write to the
            client, before declaring failure.

            **Default:** 5 seconds.

        &#34;&#34;&#34;

        self.host = host
        self.port = port
        self.backlog = backlog
        self.read_timeout = read_timeout
        self.write_timeout = write_timeout
        self._server = None
        self._nouns = {}

    def parse_data(self, data_str: str) -&gt; dict:
        &#34;&#34;&#34;
        Attempt to parse a string containing JSON-like formatting into a single dictionary.

        This function is **very** far from a full JSON parser: quite deliberately it will
        only accept a single object of name/value pairs. Any arrays are **not** accepted.
        In addition, this parser will coerce the &#39;name&#39; side of the dictionary into a
        string; or if this cannot be done will raise a &#39;RESTParseError&#39;. The &#39;value&#39; of a
        name/value pair will like-wise be coerced into its JSON type; or a &#39;RESTParseError&#39;
        raised if this cannot be done.

        The parsing is done via a very simple stack-based parser, assuming no backtracking.
        This will cope with valid JSON: but will quickly abort if the JSON is malformed,
        raising a &#39;RESTParseError&#39;. This is quite deliberate as we will only accept valid
        JSON from the client: if we can&#39;t parse the result that is the clients problem...

        The parser will also finish after the first found JSON object. We are expecting
        only a single dictionary from the client, and so attempts to add something more
        exotic will be ignored.

        Parameters
        ----------

        data_str: str
            A JSON object string, representing a single dictionary

        Returns
        -------

        dict
          A mapping of (key, value) pairs which defines the dictionary of the `data_str`
          object. All `key` values will be in Python string format: values will be as
          defined in the `data_str` object.
        &#34;&#34;&#34;

        return_dictionary = {}
        parse_stack = []
        object_start = False

        token_start = False
        token_sep = False

        token_type = &#34;ERROR&#34;
        token_str = &#34;&#34;

        for char in data_str.decode(&#34;ascii&#34;):

            # Look for the first object
            if char in [&#34;{&#34;]:
                object_start = True

            # If we are inside an object, attempt to assemble the
            # tokens
            if object_start:

                # If a &#39;&#34;&#39; is found...
                if char in [&#39;&#34;&#39;]:

                    # ... and if we are building a token, this should be the
                    # end of a string, so push it to the stack ...
                    if token_start:
                        if token_type == &#34;STR&#34;:
                            parse_stack.append(token_str)

                            token_start = False
                        else:
                            raise RESTParseError(&#34;Invalid string termination&#34;)

                        token_end = True

                    # ... Otherwise if we are not building a token, set the
                    # type marker, and start building a new string
                    else:
                        token_type = &#34;STR&#34;
                        token_start = True
                        token_str = &#34;&#34;

                # Look for the separator between a &#39;key&#39; and a &#39;value&#39;
                if char in [&#34;:&#34;]:
                    token_sep = True

                # Look for the end of a token
                if char in [&#34;,&#34;, &#34;}&#34;]:

                    # Add the key/value to the return dictionary if
                    # it appears to be valid
                    if token_sep:
                        value = parse_stack.pop()
                        key = parse_stack.pop()

                        if token_type == &#34;STR&#34;:
                            return_dictionary[key] = str(value)

                        if token_type == &#34;INT&#34;:
                            return_dictionary[key] = int(value)

                    # If this is the end of the object, then return ...
                    if char in [&#34;}&#34;]:
                        return return_dictionary

                    # .. otherwise, cleanup and continue
                    else:
                        token_type = &#34;ERROR&#34;
                        token_sep = False
                        token_start = False

                # If this isn&#39;t anything interesting, assume it is part of a token
                if object_start and ((char in ASCII_UPPERCASE) or (char in DIGITS)):
                    token_str = token_str + char

        return return_dictionary

    def register_noun(self, noun: str, handler: APIBase):
        &#34;&#34;&#34;
        Register a new object handler for the noun passed by the client.

        Parameters
        ----------

        noun: string
            String representing the noun to use in the API

        handler: `urest.api.base.APIBase`
            Object handling the request from the client
        &#34;&#34;&#34;

        old_handler = None
        print(&#34;Register!&#34;)

        try:

            if noun in self._nouns:
                old_handler = self._nouns[noun]

            if isinstance(noun, str) and isinstance(handler, APIBase):
                self._nouns[noun.lower()] = handler

        except:
            if old_handler is not None:
                self._nouns[noun] = old_handler

    async def dispatch_noun(
        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter
    ):
        &#34;&#34;&#34;
        Core client handling routine. This connects the `reader` and `writer`
        streams from the IO library to the API requests detailed by the rest
        of the server. Most of the work is done elsewhere, by the API handlers:
        this is mostly a sanity check and a routing engine.

        .. Warning::
          This routine _must_ handle arbitrary network traffic, and so
          **must** be as defensive as possible to avoid security issues in
          the API layer which results from arbitrary input stuffing and
          alike. Assume that anything from the `reader` is potentially
          dangerous to the health of the API layer: unless shown otherwise...



        Parameters
        ----------

        reader: `asyncio.StreamReader`
            An asynchronous stream, representing the network response _from_ the
            client. This is usually set-up indirectly by the `asyncio` library as part of a
            network response to the client, and will be represented by an
            [asyncio.StreamReader](https://docs.python.org/3.4/library/asyncio-stream.html#
            streamreader).

        writer: `asyncio.StreamWriter`
            An asynchronous stream, representing the network response _to_ the
            client. This is usually set-up indirectly by the `asyncio` library as part of a
            network response to the client, and will be represented by an
            [asyncio.StreamWriter](https://docs.python.org/3.4/library/asyncio-stream.html#
            streamwriter).
        &#34;&#34;&#34;

        # Attempt the parse whatever rubbish the client sends, and assemble the
        # fragments into an API request. Any failures should result in an
        # `Exception`: success should result in an API call
        try:

            # Get the raw network request and decode into UTF-8
            request_uri = await asyncio.wait_for(reader.readline(), self.read_timeout)
            request_uri = request_uri.decode(&#34;utf8&#34;)

            # Check for empty requests, and if found terminate the connection
            if request_uri in [b&#34;&#34;, b&#34;\r\n&#34;]:
                print(
                    f&#34;CLIENT: [{writer.get_extra_info(&#39;peername&#39;)[0]}] Empty request line&#34;
                )
                return

            # DEBUG
            print(
                f&#34;CLIENT URI : [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_uri}&#34;
            )

            # Get the header of the request, if it is available, decoded into UTF-8
            request_header = {}
            request_line = None

            while not request_line in [b&#34;&#34;, b&#34;\r\n&#34;]:
                request_line = await asyncio.wait_for(
                    reader.readline(), self.read_timeout
                )
                print(request_line)

                if request_line.find(b&#34;:&#34;) != -1:
                    name, value = request_line.split(b&#34;:&#34;, 1)
                    request_header[name.decode(&#34;utf-8&#34;).lower()] = value.decode(
                        &#34;utf-8&#34;
                    ).strip()

            # DEBUG
            print(
                f&#34;CLIENT HEAD: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_header}&#34;
            )

            # Check if there is a body to follow the header ...
            request_body = {}

            if &#34;content-length&#34; in request_header:
                # ... if so, get the rest of the body of the request, decoded into UTF-8

                try:
                    print(&#34;body_found&#34;)
                    request_length = int(request_header[&#34;content-length&#34;])
                    request_data = await asyncio.wait_for(
                        reader.read(request_length), self.read_timeout
                    )
                    print(request_data)
                    request_body = self.parse_data(request_data)
                except Exception as e:
                    print(e)
                    request_body = {}

            # DEBUG
            print(
                f&#34;CLIENT BODY: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_body}&#34;
            )

            ## NOTE: Below is a somewhat long-winded approach to working out
            ##       the verb is based on the longest assumed verb:
            ##       &#39;`DELETE`&#39;. To avoid later parsing errors, and to
            ##       filter out the rubbish which might cause security
            ##       issues, we will search first for a &#39;space&#39; within
            ##       the first six characters; then take either the first
            ##       six characters or the string up to the &#39;space&#39;
            ##       whichever is shorter. These can then be compared
            ##       for sanity before we run the dispatcher

            # Work out the action we need to take ...

            first_space = request_uri.find(&#34; &#34;, 0, 6)

            if first_space &gt; 6:
                first_space = 6

            verb = request_uri[0:first_space].upper()

            # ... Work out the noun defining the class we need to use to resolve the
            # action ...

            uri_root = request_uri.find(&#34;/&#34;, first_space)

            noun = &#34;&#34;
            start_noun = False

            for char in request_uri[uri_root:]:
                if char.isalpha():
                    start_noun = True
                    noun = noun + char
                else:
                    if start_noun:
                        break

            # ... and then call the appropriate handler
            response = HTTPResponse()

            if verb == &#34;DELETE&#34;:
                response.body = &#34;&#34;

            elif verb == &#34;GET&#34;:
                response.body = (
                    f&#34;{noun.lower()}: {self._nouns[noun.lower()].get_state()}&#34;
                )

            elif verb == &#34;POST&#34;:
                response.body = &#34;&#34;

            elif verb == &#34;PUT&#34;:
                response.body = &#34;&#34;

            else:
                # Clearly not one of ours
                response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
                response.status = &#34;NOT_OK&#34;

            await response.send(writer)

            writer.write(&#34;\n&#34;)

            await writer.drain()

        # Deal with any exceptions. These are mostly client errors, and since the REST
        # API _should_ be idempotent, the client _should_ be able to simply retry. So
        # we won&#39;t do anything very fancy here
        except asyncio.TimeoutError:
            pass
        except Exception as e:
            if e.args[0] == errno.ECONNRESET:  # connection reset by client
                pass
            else:
                raise e
        except:
            response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
            response.status = &#34;NOT_OK&#34;

        # In principle the response should have been sent back to the client by now.
        # But we will give it one last try, and then also try to close the connection
        # cleanly for the client. This may not work due to the earlier exceptions: but
        # we will try anyway
        finally:
            # Do a soft close, dropping our end of the connection
            # to see if the client closes ...
            await writer.drain()
            writer.close()

            # ... if the client doesn&#39;t take the hint, wait
            # for `write_timeout` seconds and then force the close
            await asyncio.sleep(self.write_timeout)
            await writer.wait_closed()

    async def start(self):
        &#34;&#34;&#34;
        Attach the method `urest.http.server.RESTServer.dispatch_noun` to an `asyncio`
        event loop, allowing the `urest.http.server.RESTServer.dispatch_noun` method to
        handle tasks representing network events from the client.

        Most of the implementation of this method is handled by
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server). In particular the
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server) method is responsible for setting up the lower-level
        networks socket, using the `host` and `port` class attributes holding the server
        (local) elements of the TCP/IP tuple. Lower level timers and queues are also
        provided by the resolution of the
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server) method, with the class attribute `backlog` being used to
        set the client (downstream) timeout.
        &#34;&#34;&#34;

        print(f&#34;SERVER: Started on {self.host}:{self.port}&#34;)
        self._server = await asyncio.start_server(
            self.dispatch_noun, self.host, self.port, self.backlog
        )

    async def stop(self):
        &#34;&#34;&#34;
        Remove the tasks from an event loop, in preparation for the termination
        of that loop. Most of the implementation of this method is handled by the
        [`close`
        method](https://docs.python.org/3.4/library/asyncio-protocol.html#asyncio.
        BaseTransport.close) of `asyncio.BaseTransport`.
        &#34;&#34;&#34;

        if self._server is not None:
            self._server.close()
            await self._server.wait_closed()
            self._server = None
            print(&#34;SERVER: Stopped&#34;)
        else:
            print(&#34;SERVER: Not started&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="urest.http.server.RESTParseError"><code class="flex name class">
<span>class <span class="ident">RESTParseError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESTParseError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="urest.http.server.RESTServer"><code class="flex name class">
<span>class <span class="ident">RESTServer</span></span>
<span>(</span><span>host:Â strÂ =Â '0.0.0.0', port:Â intÂ =Â 80, backlog:Â intÂ =Â 5, read_timeout:Â intÂ =Â 30, write_timeout:Â intÂ =Â 5)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the server with reasonable defaults. These should work
for most cases, and should be set so that most clients won't have
to touch them.</p>
<p>The <code><a title="urest.http.server.RESTServer" href="#urest.http.server.RESTServer">RESTServer</a></code> class acts as the primary interface
to the library, handling all the network communication with the client,
formatting the response and marshalling the API calls required to generate that
response.</p>
<p>In most cases consumers of this module will create a single instance of
the <code><a title="urest.http.server.RESTServer" href="#urest.http.server.RESTServer">RESTServer</a></code> class, and then pass the reference to the
<code><a title="urest.http.server.RESTServer.start" href="#urest.http.server.RESTServer.start">RESTServer.start()</a></code> method to an event loop of the <code>asyncio</code>
library.</p>
<p>For example the following code creates a variable <code>app</code> for the instance
of the <code><a title="urest.http.server.RESTServer" href="#urest.http.server.RESTServer">RESTServer</a></code> class, and passes this to the 'main' event
loop of the <code>asyncio</code> library</p>
<pre><code class="language-python">app = RESTServer()


if __name__ == &quot;__main__&quot;:
  loop = asyncio.get_event_loop()
  loop.create_task(app.start())
  loop.run_forever()
</code></pre>
<p>The <code><a title="urest.http.server.RESTServer.start" href="#urest.http.server.RESTServer.start">RESTServer.start()</a></code> method is expected to be used
in a <a href="https://docs.python.org/3.4/library/asyncio-eventloop.html"><code>asyncio</code> event
loop</a>, as above;
with the tasks being handled by the <code><a title="urest.http.server.RESTServer.dispatch_noun" href="#urest.http.server.RESTServer.dispatch_noun">RESTServer.dispatch_noun()</a></code>
method. If the event loop is required to be closed, or destroyed, the tasks
can be removed using the <code><a title="urest.http.server.RESTServer.stop" href="#urest.http.server.RESTServer.stop">RESTServer.stop()</a></code> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The code in this class assumes the <code>asyncio</code> library with an interface
roughly equivalent to Python 3.4: although the MicroPython module supports <em>some</em>
later extensions. Given the code churn in the <code>asyncio</code> module between Python 3.4
and Python 3.10, careful testing is required to ensure implementation compatibility.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>A resolvable DNS host name or IP address. Note that the exact requirements are
determined by the
<a href="&lt;https://docs.python.org/3.4/library/&gt;
asyncio-eventloop.html#asyncio.BaseEventLoop.create_server"><code>asyncio.BaseEventLoop.create_server</code></a> method, which should
be checked carefully for implementation defined limitations.</p>
<p><strong>Default:</strong> An IPv4 sock on the local host.</p>
</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>integer</code></dt>
<dd>
<p>The local (server) port to bind the socket to. Note that the exact requirements are
determined by the
<a href="&lt;https://docs.python.org/3.4/library/&gt;
asyncio-eventloop.html#asyncio.BaseEventLoop.create_server"><code>asyncio.BaseEventLoop.create_server</code></a> method, which should
be checked carefully for implementation defined limitations (e.g. extra privileges
required for system ports).</p>
<p><strong>Default:</strong> The IANA Assigned port 80 for an HTTP Server.</p>
</dd>
<dt><strong><code>backlog</code></strong> :&ensp;<code>integer</code></dt>
<dd>
<p>Roughly the size of the pool of connections for the underlying
<code>socket</code>. Once this value has been exceeded, the tasks will be suspended by the
co-routine handler until the underlying <code>socket</code> can clear them. Note that the
size (and interpretation) of this value is system dependent: see the <a href="https://docs.python.org/3.4/library/socket.html#module-socket"><code>socket</code>
API</a> for more
details.</p>
<p><strong>Default:</strong> 5 (typically the maximum pool size allowed).</p>
</dd>
<dt><strong><code>read_timeout</code></strong> :&ensp;<code>integer</code></dt>
<dd>
<p>Length of time in seconds to wait for a response from the client before declaring
failure.</p>
<p><strong>Default:</strong> 30 seconds.</p>
</dd>
<dt><strong><code>write_timeout</code></strong> :&ensp;<code>integer</code></dt>
<dd>
<p>Length of time in seconds to wait for the network socket to accept a write to the
client, before declaring failure.</p>
<p><strong>Default:</strong> 5 seconds.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESTServer:

    #
    def __init__(
        self,
        host: str = &#34;0.0.0.0&#34;,
        port: int = 80,
        backlog: int = 5,
        read_timeout: int = 30,
        write_timeout: int = 5,
    ):
        &#34;&#34;&#34;Initialise the server with reasonable defaults. These should work
        for most cases, and should be set so that most clients won&#39;t have
        to touch them.

        The `urest.http.server.RESTServer` class acts as the primary interface
        to the library, handling all the network communication with the client,
        formatting the response and marshalling the API calls required to generate that
        response.

        In most cases consumers of this module will create a single instance of
        the `urest.http.server.RESTServer` class, and then pass the reference to the
        `urest.http.server.RESTServer.start` method to an event loop of the `asyncio`
        library.

        For example the following code creates a variable `app` for the instance
        of the `urest.http.server.RESTServer` class, and passes this to the &#39;main&#39; event
        loop of the `asyncio` library

        ```python
        app = RESTServer()


        if __name__ == &#34;__main__&#34;:
          loop = asyncio.get_event_loop()
          loop.create_task(app.start())
          loop.run_forever()
        ```

        The `urest.http.server.RESTServer.start` method is expected to be used
        in a [`asyncio` event
        loop](https://docs.python.org/3.4/library/asyncio-eventloop.html), as above;
        with the tasks being handled by the `urest.http.server.RESTServer.dispatch_noun`
        method. If the event loop is required to be closed, or destroyed, the tasks
        can be removed using the `urest.http.server.RESTServer.stop` method.

        .. Note::
          The code in this class assumes the `asyncio` library with an interface
          roughly equivalent to Python 3.4: although the MicroPython module supports _some_
          later extensions. Given the code churn in the `asyncio` module between Python 3.4
          and Python 3.10, careful testing is required to ensure implementation compatibility.

        Parameters
        ----------

        host: string
            A resolvable DNS host name or IP address. Note that the exact requirements are
            determined by the
            [`asyncio.BaseEventLoop.create_server`](https://docs.python.org/3.4/library/
            asyncio-eventloop.html#asyncio.BaseEventLoop.create_server) method, which should
            be checked carefully for implementation defined limitations.

            **Default:** An IPv4 sock on the local host.

        port: integer
            The local (server) port to bind the socket to. Note that the exact requirements are
            determined by the
            [`asyncio.BaseEventLoop.create_server`](https://docs.python.org/3.4/library/
            asyncio-eventloop.html#asyncio.BaseEventLoop.create_server) method, which should
            be checked carefully for implementation defined limitations (e.g. extra privileges
            required for system ports).

            **Default:** The IANA Assigned port 80 for an HTTP Server.

        backlog: integer
            Roughly the size of the pool of connections for the underlying
            `socket`. Once this value has been exceeded, the tasks will be suspended by the
            co-routine handler until the underlying `socket` can clear them. Note that the
            size (and interpretation) of this value is system dependent: see the [`socket`
            API](https://docs.python.org/3.4/library/socket.html#module-socket) for more
            details.

            **Default:** 5 (typically the maximum pool size allowed).

        read_timeout: integer
            Length of time in seconds to wait for a response from the client before declaring
            failure.

            **Default:** 30 seconds.

        write_timeout: integer
            Length of time in seconds to wait for the network socket to accept a write to the
            client, before declaring failure.

            **Default:** 5 seconds.

        &#34;&#34;&#34;

        self.host = host
        self.port = port
        self.backlog = backlog
        self.read_timeout = read_timeout
        self.write_timeout = write_timeout
        self._server = None
        self._nouns = {}

    def parse_data(self, data_str: str) -&gt; dict:
        &#34;&#34;&#34;
        Attempt to parse a string containing JSON-like formatting into a single dictionary.

        This function is **very** far from a full JSON parser: quite deliberately it will
        only accept a single object of name/value pairs. Any arrays are **not** accepted.
        In addition, this parser will coerce the &#39;name&#39; side of the dictionary into a
        string; or if this cannot be done will raise a &#39;RESTParseError&#39;. The &#39;value&#39; of a
        name/value pair will like-wise be coerced into its JSON type; or a &#39;RESTParseError&#39;
        raised if this cannot be done.

        The parsing is done via a very simple stack-based parser, assuming no backtracking.
        This will cope with valid JSON: but will quickly abort if the JSON is malformed,
        raising a &#39;RESTParseError&#39;. This is quite deliberate as we will only accept valid
        JSON from the client: if we can&#39;t parse the result that is the clients problem...

        The parser will also finish after the first found JSON object. We are expecting
        only a single dictionary from the client, and so attempts to add something more
        exotic will be ignored.

        Parameters
        ----------

        data_str: str
            A JSON object string, representing a single dictionary

        Returns
        -------

        dict
          A mapping of (key, value) pairs which defines the dictionary of the `data_str`
          object. All `key` values will be in Python string format: values will be as
          defined in the `data_str` object.
        &#34;&#34;&#34;

        return_dictionary = {}
        parse_stack = []
        object_start = False

        token_start = False
        token_sep = False

        token_type = &#34;ERROR&#34;
        token_str = &#34;&#34;

        for char in data_str.decode(&#34;ascii&#34;):

            # Look for the first object
            if char in [&#34;{&#34;]:
                object_start = True

            # If we are inside an object, attempt to assemble the
            # tokens
            if object_start:

                # If a &#39;&#34;&#39; is found...
                if char in [&#39;&#34;&#39;]:

                    # ... and if we are building a token, this should be the
                    # end of a string, so push it to the stack ...
                    if token_start:
                        if token_type == &#34;STR&#34;:
                            parse_stack.append(token_str)

                            token_start = False
                        else:
                            raise RESTParseError(&#34;Invalid string termination&#34;)

                        token_end = True

                    # ... Otherwise if we are not building a token, set the
                    # type marker, and start building a new string
                    else:
                        token_type = &#34;STR&#34;
                        token_start = True
                        token_str = &#34;&#34;

                # Look for the separator between a &#39;key&#39; and a &#39;value&#39;
                if char in [&#34;:&#34;]:
                    token_sep = True

                # Look for the end of a token
                if char in [&#34;,&#34;, &#34;}&#34;]:

                    # Add the key/value to the return dictionary if
                    # it appears to be valid
                    if token_sep:
                        value = parse_stack.pop()
                        key = parse_stack.pop()

                        if token_type == &#34;STR&#34;:
                            return_dictionary[key] = str(value)

                        if token_type == &#34;INT&#34;:
                            return_dictionary[key] = int(value)

                    # If this is the end of the object, then return ...
                    if char in [&#34;}&#34;]:
                        return return_dictionary

                    # .. otherwise, cleanup and continue
                    else:
                        token_type = &#34;ERROR&#34;
                        token_sep = False
                        token_start = False

                # If this isn&#39;t anything interesting, assume it is part of a token
                if object_start and ((char in ASCII_UPPERCASE) or (char in DIGITS)):
                    token_str = token_str + char

        return return_dictionary

    def register_noun(self, noun: str, handler: APIBase):
        &#34;&#34;&#34;
        Register a new object handler for the noun passed by the client.

        Parameters
        ----------

        noun: string
            String representing the noun to use in the API

        handler: `urest.api.base.APIBase`
            Object handling the request from the client
        &#34;&#34;&#34;

        old_handler = None
        print(&#34;Register!&#34;)

        try:

            if noun in self._nouns:
                old_handler = self._nouns[noun]

            if isinstance(noun, str) and isinstance(handler, APIBase):
                self._nouns[noun.lower()] = handler

        except:
            if old_handler is not None:
                self._nouns[noun] = old_handler

    async def dispatch_noun(
        self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter
    ):
        &#34;&#34;&#34;
        Core client handling routine. This connects the `reader` and `writer`
        streams from the IO library to the API requests detailed by the rest
        of the server. Most of the work is done elsewhere, by the API handlers:
        this is mostly a sanity check and a routing engine.

        .. Warning::
          This routine _must_ handle arbitrary network traffic, and so
          **must** be as defensive as possible to avoid security issues in
          the API layer which results from arbitrary input stuffing and
          alike. Assume that anything from the `reader` is potentially
          dangerous to the health of the API layer: unless shown otherwise...



        Parameters
        ----------

        reader: `asyncio.StreamReader`
            An asynchronous stream, representing the network response _from_ the
            client. This is usually set-up indirectly by the `asyncio` library as part of a
            network response to the client, and will be represented by an
            [asyncio.StreamReader](https://docs.python.org/3.4/library/asyncio-stream.html#
            streamreader).

        writer: `asyncio.StreamWriter`
            An asynchronous stream, representing the network response _to_ the
            client. This is usually set-up indirectly by the `asyncio` library as part of a
            network response to the client, and will be represented by an
            [asyncio.StreamWriter](https://docs.python.org/3.4/library/asyncio-stream.html#
            streamwriter).
        &#34;&#34;&#34;

        # Attempt the parse whatever rubbish the client sends, and assemble the
        # fragments into an API request. Any failures should result in an
        # `Exception`: success should result in an API call
        try:

            # Get the raw network request and decode into UTF-8
            request_uri = await asyncio.wait_for(reader.readline(), self.read_timeout)
            request_uri = request_uri.decode(&#34;utf8&#34;)

            # Check for empty requests, and if found terminate the connection
            if request_uri in [b&#34;&#34;, b&#34;\r\n&#34;]:
                print(
                    f&#34;CLIENT: [{writer.get_extra_info(&#39;peername&#39;)[0]}] Empty request line&#34;
                )
                return

            # DEBUG
            print(
                f&#34;CLIENT URI : [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_uri}&#34;
            )

            # Get the header of the request, if it is available, decoded into UTF-8
            request_header = {}
            request_line = None

            while not request_line in [b&#34;&#34;, b&#34;\r\n&#34;]:
                request_line = await asyncio.wait_for(
                    reader.readline(), self.read_timeout
                )
                print(request_line)

                if request_line.find(b&#34;:&#34;) != -1:
                    name, value = request_line.split(b&#34;:&#34;, 1)
                    request_header[name.decode(&#34;utf-8&#34;).lower()] = value.decode(
                        &#34;utf-8&#34;
                    ).strip()

            # DEBUG
            print(
                f&#34;CLIENT HEAD: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_header}&#34;
            )

            # Check if there is a body to follow the header ...
            request_body = {}

            if &#34;content-length&#34; in request_header:
                # ... if so, get the rest of the body of the request, decoded into UTF-8

                try:
                    print(&#34;body_found&#34;)
                    request_length = int(request_header[&#34;content-length&#34;])
                    request_data = await asyncio.wait_for(
                        reader.read(request_length), self.read_timeout
                    )
                    print(request_data)
                    request_body = self.parse_data(request_data)
                except Exception as e:
                    print(e)
                    request_body = {}

            # DEBUG
            print(
                f&#34;CLIENT BODY: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_body}&#34;
            )

            ## NOTE: Below is a somewhat long-winded approach to working out
            ##       the verb is based on the longest assumed verb:
            ##       &#39;`DELETE`&#39;. To avoid later parsing errors, and to
            ##       filter out the rubbish which might cause security
            ##       issues, we will search first for a &#39;space&#39; within
            ##       the first six characters; then take either the first
            ##       six characters or the string up to the &#39;space&#39;
            ##       whichever is shorter. These can then be compared
            ##       for sanity before we run the dispatcher

            # Work out the action we need to take ...

            first_space = request_uri.find(&#34; &#34;, 0, 6)

            if first_space &gt; 6:
                first_space = 6

            verb = request_uri[0:first_space].upper()

            # ... Work out the noun defining the class we need to use to resolve the
            # action ...

            uri_root = request_uri.find(&#34;/&#34;, first_space)

            noun = &#34;&#34;
            start_noun = False

            for char in request_uri[uri_root:]:
                if char.isalpha():
                    start_noun = True
                    noun = noun + char
                else:
                    if start_noun:
                        break

            # ... and then call the appropriate handler
            response = HTTPResponse()

            if verb == &#34;DELETE&#34;:
                response.body = &#34;&#34;

            elif verb == &#34;GET&#34;:
                response.body = (
                    f&#34;{noun.lower()}: {self._nouns[noun.lower()].get_state()}&#34;
                )

            elif verb == &#34;POST&#34;:
                response.body = &#34;&#34;

            elif verb == &#34;PUT&#34;:
                response.body = &#34;&#34;

            else:
                # Clearly not one of ours
                response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
                response.status = &#34;NOT_OK&#34;

            await response.send(writer)

            writer.write(&#34;\n&#34;)

            await writer.drain()

        # Deal with any exceptions. These are mostly client errors, and since the REST
        # API _should_ be idempotent, the client _should_ be able to simply retry. So
        # we won&#39;t do anything very fancy here
        except asyncio.TimeoutError:
            pass
        except Exception as e:
            if e.args[0] == errno.ECONNRESET:  # connection reset by client
                pass
            else:
                raise e
        except:
            response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
            response.status = &#34;NOT_OK&#34;

        # In principle the response should have been sent back to the client by now.
        # But we will give it one last try, and then also try to close the connection
        # cleanly for the client. This may not work due to the earlier exceptions: but
        # we will try anyway
        finally:
            # Do a soft close, dropping our end of the connection
            # to see if the client closes ...
            await writer.drain()
            writer.close()

            # ... if the client doesn&#39;t take the hint, wait
            # for `write_timeout` seconds and then force the close
            await asyncio.sleep(self.write_timeout)
            await writer.wait_closed()

    async def start(self):
        &#34;&#34;&#34;
        Attach the method `urest.http.server.RESTServer.dispatch_noun` to an `asyncio`
        event loop, allowing the `urest.http.server.RESTServer.dispatch_noun` method to
        handle tasks representing network events from the client.

        Most of the implementation of this method is handled by
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server). In particular the
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server) method is responsible for setting up the lower-level
        networks socket, using the `host` and `port` class attributes holding the server
        (local) elements of the TCP/IP tuple. Lower level timers and queues are also
        provided by the resolution of the
        [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
        asyncio.start_server) method, with the class attribute `backlog` being used to
        set the client (downstream) timeout.
        &#34;&#34;&#34;

        print(f&#34;SERVER: Started on {self.host}:{self.port}&#34;)
        self._server = await asyncio.start_server(
            self.dispatch_noun, self.host, self.port, self.backlog
        )

    async def stop(self):
        &#34;&#34;&#34;
        Remove the tasks from an event loop, in preparation for the termination
        of that loop. Most of the implementation of this method is handled by the
        [`close`
        method](https://docs.python.org/3.4/library/asyncio-protocol.html#asyncio.
        BaseTransport.close) of `asyncio.BaseTransport`.
        &#34;&#34;&#34;

        if self._server is not None:
            self._server.close()
            await self._server.wait_closed()
            self._server = None
            print(&#34;SERVER: Stopped&#34;)
        else:
            print(&#34;SERVER: Not started&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="urest.http.server.RESTServer.dispatch_noun"><code class="name flex">
<span>async def <span class="ident">dispatch_noun</span></span>(<span>self, reader:Â asyncio.streams.StreamReader, writer:Â asyncio.streams.StreamWriter)</span>
</code></dt>
<dd>
<div class="desc"><p>Core client handling routine. This connects the <code>reader</code> and <code>writer</code>
streams from the IO library to the API requests detailed by the rest
of the server. Most of the work is done elsewhere, by the API handlers:
this is mostly a sanity check and a routing engine.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This routine <em>must</em> handle arbitrary network traffic, and so
<strong>must</strong> be as defensive as possible to avoid security issues in
the API layer which results from arbitrary input stuffing and
alike. Assume that anything from the <code>reader</code> is potentially
dangerous to the health of the API layer: unless shown otherwise&hellip;</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reader</code></strong> :&ensp;<code>asyncio.StreamReader</code></dt>
<dd>An asynchronous stream, representing the network response <em>from</em> the
client. This is usually set-up indirectly by the <code>asyncio</code> library as part of a
network response to the client, and will be represented by an
<a href="&lt;https://docs.python.org/3.4/library/asyncio-stream.html#&gt;
streamreader">asyncio.StreamReader</a>.</dd>
<dt><strong><code>writer</code></strong> :&ensp;<code>asyncio.StreamWriter</code></dt>
<dd>An asynchronous stream, representing the network response <em>to</em> the
client. This is usually set-up indirectly by the <code>asyncio</code> library as part of a
network response to the client, and will be represented by an
<a href="&lt;https://docs.python.org/3.4/library/asyncio-stream.html#&gt;
streamwriter">asyncio.StreamWriter</a>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch_noun(
    self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter
):
    &#34;&#34;&#34;
    Core client handling routine. This connects the `reader` and `writer`
    streams from the IO library to the API requests detailed by the rest
    of the server. Most of the work is done elsewhere, by the API handlers:
    this is mostly a sanity check and a routing engine.

    .. Warning::
      This routine _must_ handle arbitrary network traffic, and so
      **must** be as defensive as possible to avoid security issues in
      the API layer which results from arbitrary input stuffing and
      alike. Assume that anything from the `reader` is potentially
      dangerous to the health of the API layer: unless shown otherwise...



    Parameters
    ----------

    reader: `asyncio.StreamReader`
        An asynchronous stream, representing the network response _from_ the
        client. This is usually set-up indirectly by the `asyncio` library as part of a
        network response to the client, and will be represented by an
        [asyncio.StreamReader](https://docs.python.org/3.4/library/asyncio-stream.html#
        streamreader).

    writer: `asyncio.StreamWriter`
        An asynchronous stream, representing the network response _to_ the
        client. This is usually set-up indirectly by the `asyncio` library as part of a
        network response to the client, and will be represented by an
        [asyncio.StreamWriter](https://docs.python.org/3.4/library/asyncio-stream.html#
        streamwriter).
    &#34;&#34;&#34;

    # Attempt the parse whatever rubbish the client sends, and assemble the
    # fragments into an API request. Any failures should result in an
    # `Exception`: success should result in an API call
    try:

        # Get the raw network request and decode into UTF-8
        request_uri = await asyncio.wait_for(reader.readline(), self.read_timeout)
        request_uri = request_uri.decode(&#34;utf8&#34;)

        # Check for empty requests, and if found terminate the connection
        if request_uri in [b&#34;&#34;, b&#34;\r\n&#34;]:
            print(
                f&#34;CLIENT: [{writer.get_extra_info(&#39;peername&#39;)[0]}] Empty request line&#34;
            )
            return

        # DEBUG
        print(
            f&#34;CLIENT URI : [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_uri}&#34;
        )

        # Get the header of the request, if it is available, decoded into UTF-8
        request_header = {}
        request_line = None

        while not request_line in [b&#34;&#34;, b&#34;\r\n&#34;]:
            request_line = await asyncio.wait_for(
                reader.readline(), self.read_timeout
            )
            print(request_line)

            if request_line.find(b&#34;:&#34;) != -1:
                name, value = request_line.split(b&#34;:&#34;, 1)
                request_header[name.decode(&#34;utf-8&#34;).lower()] = value.decode(
                    &#34;utf-8&#34;
                ).strip()

        # DEBUG
        print(
            f&#34;CLIENT HEAD: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_header}&#34;
        )

        # Check if there is a body to follow the header ...
        request_body = {}

        if &#34;content-length&#34; in request_header:
            # ... if so, get the rest of the body of the request, decoded into UTF-8

            try:
                print(&#34;body_found&#34;)
                request_length = int(request_header[&#34;content-length&#34;])
                request_data = await asyncio.wait_for(
                    reader.read(request_length), self.read_timeout
                )
                print(request_data)
                request_body = self.parse_data(request_data)
            except Exception as e:
                print(e)
                request_body = {}

        # DEBUG
        print(
            f&#34;CLIENT BODY: [{writer.get_extra_info(&#39;peername&#39;)[0]}] {request_body}&#34;
        )

        ## NOTE: Below is a somewhat long-winded approach to working out
        ##       the verb is based on the longest assumed verb:
        ##       &#39;`DELETE`&#39;. To avoid later parsing errors, and to
        ##       filter out the rubbish which might cause security
        ##       issues, we will search first for a &#39;space&#39; within
        ##       the first six characters; then take either the first
        ##       six characters or the string up to the &#39;space&#39;
        ##       whichever is shorter. These can then be compared
        ##       for sanity before we run the dispatcher

        # Work out the action we need to take ...

        first_space = request_uri.find(&#34; &#34;, 0, 6)

        if first_space &gt; 6:
            first_space = 6

        verb = request_uri[0:first_space].upper()

        # ... Work out the noun defining the class we need to use to resolve the
        # action ...

        uri_root = request_uri.find(&#34;/&#34;, first_space)

        noun = &#34;&#34;
        start_noun = False

        for char in request_uri[uri_root:]:
            if char.isalpha():
                start_noun = True
                noun = noun + char
            else:
                if start_noun:
                    break

        # ... and then call the appropriate handler
        response = HTTPResponse()

        if verb == &#34;DELETE&#34;:
            response.body = &#34;&#34;

        elif verb == &#34;GET&#34;:
            response.body = (
                f&#34;{noun.lower()}: {self._nouns[noun.lower()].get_state()}&#34;
            )

        elif verb == &#34;POST&#34;:
            response.body = &#34;&#34;

        elif verb == &#34;PUT&#34;:
            response.body = &#34;&#34;

        else:
            # Clearly not one of ours
            response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
            response.status = &#34;NOT_OK&#34;

        await response.send(writer)

        writer.write(&#34;\n&#34;)

        await writer.drain()

    # Deal with any exceptions. These are mostly client errors, and since the REST
    # API _should_ be idempotent, the client _should_ be able to simply retry. So
    # we won&#39;t do anything very fancy here
    except asyncio.TimeoutError:
        pass
    except Exception as e:
        if e.args[0] == errno.ECONNRESET:  # connection reset by client
            pass
        else:
            raise e
    except:
        response.body = &#34;&lt;http&gt;&lt;body&gt;&lt;p&gt;Invalid Request&lt;/p&gt;&lt;/body&gt;&lt;/http&gt;&#34;
        response.status = &#34;NOT_OK&#34;

    # In principle the response should have been sent back to the client by now.
    # But we will give it one last try, and then also try to close the connection
    # cleanly for the client. This may not work due to the earlier exceptions: but
    # we will try anyway
    finally:
        # Do a soft close, dropping our end of the connection
        # to see if the client closes ...
        await writer.drain()
        writer.close()

        # ... if the client doesn&#39;t take the hint, wait
        # for `write_timeout` seconds and then force the close
        await asyncio.sleep(self.write_timeout)
        await writer.wait_closed()</code></pre>
</details>
</dd>
<dt id="urest.http.server.RESTServer.parse_data"><code class="name flex">
<span>def <span class="ident">parse_data</span></span>(<span>self, data_str:Â str) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to parse a string containing JSON-like formatting into a single dictionary.</p>
<p>This function is <strong>very</strong> far from a full JSON parser: quite deliberately it will
only accept a single object of name/value pairs. Any arrays are <strong>not</strong> accepted.
In addition, this parser will coerce the 'name' side of the dictionary into a
string; or if this cannot be done will raise a 'RESTParseError'. The 'value' of a
name/value pair will like-wise be coerced into its JSON type; or a 'RESTParseError'
raised if this cannot be done.</p>
<p>The parsing is done via a very simple stack-based parser, assuming no backtracking.
This will cope with valid JSON: but will quickly abort if the JSON is malformed,
raising a 'RESTParseError'. This is quite deliberate as we will only accept valid
JSON from the client: if we can't parse the result that is the clients problem&hellip;</p>
<p>The parser will also finish after the first found JSON object. We are expecting
only a single dictionary from the client, and so attempts to add something more
exotic will be ignored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_str</code></strong> :&ensp;<code>str</code></dt>
<dd>A JSON object string, representing a single dictionary</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>A mapping of (key, value) pairs which defines the dictionary of the <code>data_str</code>
object. All <code>key</code> values will be in Python string format: values will be as
defined in the <code>data_str</code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_data(self, data_str: str) -&gt; dict:
    &#34;&#34;&#34;
    Attempt to parse a string containing JSON-like formatting into a single dictionary.

    This function is **very** far from a full JSON parser: quite deliberately it will
    only accept a single object of name/value pairs. Any arrays are **not** accepted.
    In addition, this parser will coerce the &#39;name&#39; side of the dictionary into a
    string; or if this cannot be done will raise a &#39;RESTParseError&#39;. The &#39;value&#39; of a
    name/value pair will like-wise be coerced into its JSON type; or a &#39;RESTParseError&#39;
    raised if this cannot be done.

    The parsing is done via a very simple stack-based parser, assuming no backtracking.
    This will cope with valid JSON: but will quickly abort if the JSON is malformed,
    raising a &#39;RESTParseError&#39;. This is quite deliberate as we will only accept valid
    JSON from the client: if we can&#39;t parse the result that is the clients problem...

    The parser will also finish after the first found JSON object. We are expecting
    only a single dictionary from the client, and so attempts to add something more
    exotic will be ignored.

    Parameters
    ----------

    data_str: str
        A JSON object string, representing a single dictionary

    Returns
    -------

    dict
      A mapping of (key, value) pairs which defines the dictionary of the `data_str`
      object. All `key` values will be in Python string format: values will be as
      defined in the `data_str` object.
    &#34;&#34;&#34;

    return_dictionary = {}
    parse_stack = []
    object_start = False

    token_start = False
    token_sep = False

    token_type = &#34;ERROR&#34;
    token_str = &#34;&#34;

    for char in data_str.decode(&#34;ascii&#34;):

        # Look for the first object
        if char in [&#34;{&#34;]:
            object_start = True

        # If we are inside an object, attempt to assemble the
        # tokens
        if object_start:

            # If a &#39;&#34;&#39; is found...
            if char in [&#39;&#34;&#39;]:

                # ... and if we are building a token, this should be the
                # end of a string, so push it to the stack ...
                if token_start:
                    if token_type == &#34;STR&#34;:
                        parse_stack.append(token_str)

                        token_start = False
                    else:
                        raise RESTParseError(&#34;Invalid string termination&#34;)

                    token_end = True

                # ... Otherwise if we are not building a token, set the
                # type marker, and start building a new string
                else:
                    token_type = &#34;STR&#34;
                    token_start = True
                    token_str = &#34;&#34;

            # Look for the separator between a &#39;key&#39; and a &#39;value&#39;
            if char in [&#34;:&#34;]:
                token_sep = True

            # Look for the end of a token
            if char in [&#34;,&#34;, &#34;}&#34;]:

                # Add the key/value to the return dictionary if
                # it appears to be valid
                if token_sep:
                    value = parse_stack.pop()
                    key = parse_stack.pop()

                    if token_type == &#34;STR&#34;:
                        return_dictionary[key] = str(value)

                    if token_type == &#34;INT&#34;:
                        return_dictionary[key] = int(value)

                # If this is the end of the object, then return ...
                if char in [&#34;}&#34;]:
                    return return_dictionary

                # .. otherwise, cleanup and continue
                else:
                    token_type = &#34;ERROR&#34;
                    token_sep = False
                    token_start = False

            # If this isn&#39;t anything interesting, assume it is part of a token
            if object_start and ((char in ASCII_UPPERCASE) or (char in DIGITS)):
                token_str = token_str + char

    return return_dictionary</code></pre>
</details>
</dd>
<dt id="urest.http.server.RESTServer.register_noun"><code class="name flex">
<span>def <span class="ident">register_noun</span></span>(<span>self, noun:Â str, handler:Â <a title="urest.api.base.APIBase" href="../api/base.html#urest.api.base.APIBase">APIBase</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new object handler for the noun passed by the client.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>noun</code></strong> :&ensp;<code>string</code></dt>
<dd>String representing the noun to use in the API</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code><a title="urest.api.base.APIBase" href="../api/base.html#urest.api.base.APIBase">APIBase</a></code></dt>
<dd>Object handling the request from the client</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_noun(self, noun: str, handler: APIBase):
    &#34;&#34;&#34;
    Register a new object handler for the noun passed by the client.

    Parameters
    ----------

    noun: string
        String representing the noun to use in the API

    handler: `urest.api.base.APIBase`
        Object handling the request from the client
    &#34;&#34;&#34;

    old_handler = None
    print(&#34;Register!&#34;)

    try:

        if noun in self._nouns:
            old_handler = self._nouns[noun]

        if isinstance(noun, str) and isinstance(handler, APIBase):
            self._nouns[noun.lower()] = handler

    except:
        if old_handler is not None:
            self._nouns[noun] = old_handler</code></pre>
</details>
</dd>
<dt id="urest.http.server.RESTServer.start"><code class="name flex">
<span>async def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach the method <code><a title="urest.http.server.RESTServer.dispatch_noun" href="#urest.http.server.RESTServer.dispatch_noun">RESTServer.dispatch_noun()</a></code> to an <code>asyncio</code>
event loop, allowing the <code><a title="urest.http.server.RESTServer.dispatch_noun" href="#urest.http.server.RESTServer.dispatch_noun">RESTServer.dispatch_noun()</a></code> method to
handle tasks representing network events from the client.</p>
<p>Most of the implementation of this method is handled by
<a href="&lt;https://docs.python.org/3.4/library/asyncio-stream.html#&gt;
asyncio.start_server">asyncio.start_server</a>. In particular the
<a href="&lt;https://docs.python.org/3.4/library/asyncio-stream.html#&gt;
asyncio.start_server">asyncio.start_server</a> method is responsible for setting up the lower-level
networks socket, using the <code>host</code> and <code>port</code> class attributes holding the server
(local) elements of the TCP/IP tuple. Lower level timers and queues are also
provided by the resolution of the
<a href="&lt;https://docs.python.org/3.4/library/asyncio-stream.html#&gt;
asyncio.start_server">asyncio.start_server</a> method, with the class attribute <code>backlog</code> being used to
set the client (downstream) timeout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def start(self):
    &#34;&#34;&#34;
    Attach the method `urest.http.server.RESTServer.dispatch_noun` to an `asyncio`
    event loop, allowing the `urest.http.server.RESTServer.dispatch_noun` method to
    handle tasks representing network events from the client.

    Most of the implementation of this method is handled by
    [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
    asyncio.start_server). In particular the
    [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
    asyncio.start_server) method is responsible for setting up the lower-level
    networks socket, using the `host` and `port` class attributes holding the server
    (local) elements of the TCP/IP tuple. Lower level timers and queues are also
    provided by the resolution of the
    [asyncio.start_server](https://docs.python.org/3.4/library/asyncio-stream.html#
    asyncio.start_server) method, with the class attribute `backlog` being used to
    set the client (downstream) timeout.
    &#34;&#34;&#34;

    print(f&#34;SERVER: Started on {self.host}:{self.port}&#34;)
    self._server = await asyncio.start_server(
        self.dispatch_noun, self.host, self.port, self.backlog
    )</code></pre>
</details>
</dd>
<dt id="urest.http.server.RESTServer.stop"><code class="name flex">
<span>async def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the tasks from an event loop, in preparation for the termination
of that loop. Most of the implementation of this method is handled by the
<a href="&lt;https://docs.python.org/3.4/library/asyncio-protocol.html#asyncio.&gt;
BaseTransport.close"><code>close</code>
method</a> of <code>asyncio.BaseTransport</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stop(self):
    &#34;&#34;&#34;
    Remove the tasks from an event loop, in preparation for the termination
    of that loop. Most of the implementation of this method is handled by the
    [`close`
    method](https://docs.python.org/3.4/library/asyncio-protocol.html#asyncio.
    BaseTransport.close) of `asyncio.BaseTransport`.
    &#34;&#34;&#34;

    if self._server is not None:
        self._server.close()
        await self._server.wait_closed()
        self._server = None
        print(&#34;SERVER: Stopped&#34;)
    else:
        print(&#34;SERVER: Not started&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="urest.http.server.RESTServerError"><code class="flex name class">
<span>class <span class="ident">RESTServerError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESTServerError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#standards">Standards</a></li>
<li><a href="#licence">Licence</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="urest.http" href="index.html">urest.http</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="urest.http.server.RESTParseError" href="#urest.http.server.RESTParseError">RESTParseError</a></code></h4>
</li>
<li>
<h4><code><a title="urest.http.server.RESTServer" href="#urest.http.server.RESTServer">RESTServer</a></code></h4>
<ul class="">
<li><code><a title="urest.http.server.RESTServer.dispatch_noun" href="#urest.http.server.RESTServer.dispatch_noun">dispatch_noun</a></code></li>
<li><code><a title="urest.http.server.RESTServer.parse_data" href="#urest.http.server.RESTServer.parse_data">parse_data</a></code></li>
<li><code><a title="urest.http.server.RESTServer.register_noun" href="#urest.http.server.RESTServer.register_noun">register_noun</a></code></li>
<li><code><a title="urest.http.server.RESTServer.start" href="#urest.http.server.RESTServer.start">start</a></code></li>
<li><code><a title="urest.http.server.RESTServer.stop" href="#urest.http.server.RESTServer.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="urest.http.server.RESTServerError" href="#urest.http.server.RESTServerError">RESTServerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>